<!DOCTYPE html>
<html lang="en">
<head>
  <title>MediaStream Recording</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <script type="text/javascript" src=
  'https://www.w3.org/Tools/respec/respec-w3c-common' class='remove'>
  </script>
  <script type="text/javascript" src="MediaRecorder.js" class='remove'>
  // &lt;!-- keep this comment --&gt; //
  </script>
</head>
<body>
  <section id="abstract">
    <p>This document defines a recording API for use with MediaStreams as
    defined in [[!GETUSERMEDIA]]</p>
  </section>
  <section id="sotd">
    <p>This document is not complete. It is subject to major changes and, while
    early experimentations are encouraged, it is therefore not intended for
    implementation. The Media Capture Task Force expects this specification to
    evolve significantly based on:</p>
    <ul>
      <li>Privacy issues that arise when capturing media.</li>
      <li>Technical discussions within the task force.</li>
      <li>Experience gained through early experimentations.</li>
      <li>Feedback received from other groups and individuals.</li>
    </ul>
  </section>
  <section id="overview" class="informative">
    <h2>Overview</h2>

    <p>This API attempts to make basic recording very simple, while still
    allowing for more complex use cases. In the simplest case, the application
    instantiates a <code><a>MediaRecorder</a></code> object, calls
    <a href="#dom-mediarecorder-start">start()</a> and then calls
    <a href="#dom-mediarecorder-stop">stop()</a> or waits for the
    MediaStreamTrack(s) to be ended. The contents of the recording will be made
    available in the platform's default encoding via the <a
    href="#dom-mediarecorder-ondataavailable">ondataavailable</a> event.
    Functions are available to query the platform's available set of encodings,
    and to select the desired ones if the author wishes. The application can
    also choose how much data it wants to receive at one time. By default a <a
    href="https://www.w3.org/TR/FileAPI/#blob"><code>Blob</code></a> containing
    the entire recording is returned when the recording finishes. However the
    application can choose to receive smaller buffers of data at regular
    intervals.</p>

  </section>
  <section id="not-conformance" class="informative">
    <h2>Conformance</h2>
    <p>This specification defines conformance criteria that apply to a single
    product: the <dfn>user agent</dfn> that implements the interfaces that it
    contains.</p>
    <p>Conformance requirements phrased as algorithms or specific steps may be
    implemented in any manner, so long as the end result is equivalent to the
    behavior specified in this document.</p>
    <p>Implementations that use ECMAScript to implement the APIs defined in
    this specification must implement them in a manner consistent with the
    ECMAScript Bindings defined in the Web IDL specification [[!WEBIDL]], as
    this specification uses that specification and terminology.</p>
  </section>
  <section id="MediaRecorderAPI">
    <h2>Media Recorder API</h2>
    <div>
      <pre class="idl">
      [Constructor (MediaStream stream, optional MediaRecorderOptions options)]
      interface MediaRecorder : EventTarget {
        readonly attribute MediaStream stream;
        readonly attribute DOMString mimeType;
        readonly attribute RecordingState state;
        attribute EventHandler onstart;
        attribute EventHandler onstop;
        attribute EventHandler ondataavailable;
        attribute EventHandler onpause;
        attribute EventHandler onresume;
        attribute EventHandler onerror;
        readonly attribute unsigned long videoBitsPerSecond;
        readonly attribute unsigned long audioBitsPerSecond;
        void start (optional long timeslice);
        void stop ();
        void pause ();
        void resume ();
        void requestData ();
        static boolean isTypeSupported (DOMString type);
      };
      </pre>
      <section>
        <h2>Constructors</h2>
        <dl data-link-for="MediaRecorder" data-dfn-for="MediaRecorder" class=
        "constructors">
          <dt><dfn><code>MediaRecorder</code></dfn></dt>
          <dd>
            <table class="parameters">
              <tbody>
                <tr>
                  <th>Parameter</th>
                  <th>Type</th>
                  <th>Nullable</th>
                  <th>Optional</th>
                  <th>Description</th>
                </tr>
                <tr>
                  <td class="prmName">stream</td>
                  <td class="prmType"><code>MediaStream</code></td>
                  <td class="prmNullFalse"><span role="img" aria-label=
                  "False">&#10008;</span></td>
                  <td class="prmOptFalse"><span role="img" aria-label=
                  "False">&#10008;</span></td>
                  <td class="prmDesc">The MediaStream to be recorded. This will
                  be the value of the <code>stream</code> attribute. See
                  [[!GETUSERMEDIA]] for the definition of MediaStream.</td>
                </tr>
                <tr>
                  <td class="prmName">options</td>
                  <td class="prmType"><code><a>MediaRecorderOptions</a></code></td>
                  <td class="prmNullFalse"><span role="img" aria-label=
                  "False">&#10008;</span></td>
                  <td class="prmOptTrue"><span role="img" aria-label=
                  "True">&#10004;</span></td>
                  <td class="prmDesc">A dictionary of options to for the UA
                  instructing how the recording will take part.
                  <code>options.mimeType</code>, if present, will become the
                  value of <code>mimeType</code> attribute.</td>
                </tr>
              </tbody>
            </table>
          </dd>
        </dl>
      </section>
      <section>
        <h2>Attributes</h2>
        <dl data-link-for="MediaRecorder" data-dfn-for="MediaRecorder" class=
        "attributes">
          <dt><dfn><code>stream</code></dfn> of type <span class=
          "idlAttrType"><a>MediaStream</a></span>, readonly</dt>
          <dd>The MediaStream to be recorded.</dd>

          <dt><dfn><code>mimeType</code></dfn> of type <span class=
          "idlAttrType"><a>DOMString</a></span>, readonly</dt>

          <dd>The MIME type [[!RFC2046]] that has been selected as the container
          for recording. This entry includes all the parameters to the base
          <code>mimeType</code>. The UA should be able to play back any of the
          MIME types it supports for recording. For example, it should be able
          to display a video recording in the HTML &lt;video&gt; tag. The
          default value for this property is platform-specific.

          <div class="note"> <code><a>mimeType</a></code> specifies the media
          type and container format for the recording via a type/subtype
          combination, with the codecs and/or profiles parameters [[RFC6381]]
          specified where ambiguity might arise. Individual codecs might have
          further optional specific parameters. </div></dd>

          <dt><dfn><code>state</code></dfn> of type <span class=
          "idlAttrType"><a>RecordingState</a></span>, readonly</dt> <dd>The
          current state of the MediaRecorder object. When the MediaRecorder is
          created, the UA MUST set this attribute to
          <a href="#dom-recordingstate-inactive">inactive</a>.</dd>

          <dt><dfn><code>onstart</code></dfn> of type <span class=
          "idlAttrType"><a>EventHandler</a></span></dt>
          <dd>Called to handle the start event.</dd>

          <dt><dfn><code>onstop</code></dfn> of type <span class=
          "idlAttrType"><a>EventHandler</a></span></dt>
          <dd>Called to handle the stop event.</dd>

          <dt><dfn><code>ondataavailable</code></dfn> of type <span class=
          "idlAttrType"><a>EventHandler</a></span></dt>
          <dd>Called to handle the dataavailable event. The <a
          href="https://www.w3.org/TR/FileAPI/#blob"><code>Blob</code></a>
          [[!FILE-API]] of recorded data is contained in this event and can be
          accessed via its <code>data</code> attribute.</dd>

          <dt><dfn><code>onpause</code></dfn> of type <span class=
          "idlAttrType"><a>EventHandler</a></span></dt>
          <dd>Called to handle the pause event.</dd>

          <dt><dfn><code>onresume</code></dfn> of type <span class=
          "idlAttrType"><a>EventHandler</a></span></dt>
          <dd>Called to handle the resume event.</dd>

          <dt><dfn><code>onerror</code></dfn> of type <span class=
          "idlAttrType"><a>EventHandler</a></span></dt>
          <dd>Called to handle an <a>ErrorEvent</a>.</dd>

          <dt><dfn><code>videoBitsPerSecond</code></dfn> of type <span class=
          "idlAttrType"><a>unsigned long</a></span>, readonly</dt>
          <dd>The value of the Video encoding target bit rate that was passed to
          the Platform (potentially truncated, rounded, etc), or the calculated
          one if the user has specified <code>bitsPerSecond</code>.</dd>

          <dt><dfn><code>audioBitsPerSecond</code></dfn> of type <span class=
          "idlAttrType"><a>unsigned long</a></span>, readonly</dt>
          <dd>The value of the Audio encoding target bit rate that was passed to
          the Platform (potentially truncated, rounded, etc), or the calculated
          one if the user has specified <code>bitsPerSecond</code>.</dd>
        </dl>
      </section>
      <section>
        <h2>Methods</h2>
        <dl data-link-for="MediaRecorder" data-dfn-for="MediaRecorder" class=
        "methods">
          <dt><dfn><code>start</code></dfn></dt>
          <dd>
            When a <code>MediaRecorder</code> object&#8217;s
            <code>start()</code> method is invoked, the UA MUST run the
            following steps:
            <ol>
              <li>Let <var>target</var> be the MediaRecorder context object.
              </li>
              <li>Let <var>timeslice</var> be the method's first argument, if
              provided, or <code>undefined</code>. </li>

              <li>If <a>state</a> is not <a href="#dom-recordingstate-inactive">
              inactive</a>, throw an <code>InvalidStateError</code> DOMException
              and abort these steps.</li>

              <li>If the stream's isolation properties disallow access from
              this MediaRecorder, throw a <code>SecurityError</code>
              DOMException and abort these steps.</li>

              <li>Set <a>state</a> to <a href="#dom-recordingstate-recording">
              recording</a>, and run the following steps in parallel:
                <ol>
                  <li>Once media becomes available from one or more of the
                  stream's tracks, start gathering the data into a Blob
                  ([[!FILE-API]]) <var>blob</var> and queue a task, using the
                  DOM manipulation task source, to <a
                  href="https://dom.spec.whatwg.org/#concept-event-fire">fire
                  an event</a> named <code>start</code> at <var>target</var>.
                  </li>

                  <li>If at any point the stream's isolation properties change
                  so that MediaRecorder is no longer allowed access to it, the
                  UA MUST immediately stop gathering data, and queue a task,
                  using the DOM manipulation task source, that runs the
                  following steps:
                  <ol>
                    <li>Set <a>state</a> to
                    <a href="#dom-recordingstate-inactive">inactive</a>.</li>
                    <li><a href="#dfn-to-fire-an-error-event">Fire an
                    error event</a> named <code>SecurityError</code> at
                    <var>target</var>.
                    </li>
                    <li><a href="#dfn-to-fire-a-blob-event">Fire a blob event</a>
                    named <code>dataavailable</code> at <var>target</var> with
                    <var>blob</var>.</li>
                    <li><a href="https://dom.spec.whatwg.org/#concept-event-fire">
                    Fire an event</a> named <code>stop</code> at
                    <var>target</var>.</li>
                  </ol>
                  </li>

                  <li>If the UA at any point is unable to continue gathering
                  data for reasons other than isolation properties, it MUST stop
                  gathering data, and queue a task, using the DOM manipulation
                  task source, that runs the following steps:
                  <ol>
                    <li>Set <a>state</a> to
                    <a href="#dom-recordingstate-inactive">inactive</a>.</li>
                    <li><a href="#dfn-to-fire-an-error-event">Fire an
                    error event</a> named <code>UnknownError</code> at
                    <var>target</var>.
                    </li>
                    <li><a href="#dfn-to-fire-a-blob-event">Fire a blob event</a>
                    named <code>dataavailable</code> at <var>target</var> with
                    <var>blob</var>.</li>
                    <li><a href="https://dom.spec.whatwg.org/#concept-event-fire">
                    Fire an event</a> named <code>stop</code> at
                    <var>target</var>.</li>
                  </ol>
                  </li>

                  <li>If <var>timeslice</var> is not <code>undefined</code>,
                  then once a minimum of <var>timeslice</var> milliseconds of
                  data have been collected, or some minimum time slice imposed
                  by the UA, whichever is greater, start gathering data into a
                  a new Blob <var>blob</var>, and queue a task, using the DOM
                  manipulation task source, that
                  <a>fires a blob event</a> named <code>dataavailable</code>
                  at <var>target</var> with <var>blob</var>.
                  Note that an <code>undefined</code> value of
                  <var>timeslice</var> will be understood as the largest
                  <code>long</code> value.</li>

                  <li>If all recorded tracks become <a
                  href="http://www.w3.org/TR/mediacapture-streams/#track-ended">
                  ended</a> [[!GETUSERMEDIA]], then stop gathering data, and
                  queue a task, using the DOM manipulation task source, that
                  runs the following steps:
                  <ol>
                    <li>Set <a>state</a> to
                    <a href="#dom-recordingstate-inactive">inactive</a>.</li>
                    <li><a href="#dfn-to-fire-a-blob-event">Fire a blob event</a>
                    named <code>dataavailable</code> at <var>target</var> with
                    <var>blob</var>.</li>
                    <li><a href="https://dom.spec.whatwg.org/#concept-event-fire">
                    Fire an event</a> named <code>stop</code> at
                    <var>target</var>.</li>
                  </ol>
                  </li>

                </ol>
              </li>
              <li>return <code>undefined</code>.</li>
            </ol>
            <p>Note that <code>stop()</code>, <code>requestData()</code>, and
            <code>pause()</code> also affect the recording behavior.</p>

            <p>The UA MUST record the MediaStream in such a way that the
            original Tracks can be retrieved at playback time. When multiple
            Blobs are returned (because of <code>timeslice</code> or
            <code>requestData</code>), the individual Blobs need not be
            playable, but the combination of all the Blobs from a completed
            recording MUST be playable.</p>

            <p> If any Track within the MediaStream is
            <a href="https://www.w3.org/TR/mediacapture-streams/#track-muted">
            muted</a> or
            <a href="https://www.w3.org/TR/mediacapture-streams/#track-enabled">
            disabled</a> at any time (i.e., if its <code>muted</code> or
            <code>enabled</code> flag, respectively, is set to
            <code>true</code>), the UA will only record black frames or silence
            since that is the content produced by the Track.</p>

            <table class="parameters">
              <tbody>
                <tr>
                  <th>Parameter</th>
                  <th>Type</th>
                  <th>Nullable</th>
                  <th>Optional</th>
                  <th>Description</th>
                </tr>
                <tr>
                  <td class="prmName">timeslice</td>
                  <td class="prmType"><code>long</code></td>
                  <td class="prmNullFalse"><span role="img" aria-label=
                  "False">&#10008;</span></td>
                  <td class="prmOptTrue"><span role="img" aria-label=
                  "True">&#10004;</span></td>
                  <td class="prmDesc">The minimum number of milliseconds of data
                  to return in a single Blob.</td>
                </tr>
              </tbody>
            </table>
            <div>
              <em>Return type:</em> <code>void</code>
            </div>
          </dd>
          <dt><dfn><code>stop</code></dfn></dt>
          <dd>
            When a <code>MediaRecorder</code> object&#8217;s <code>stop</code>
            method is invoked, the UA MUST run the following steps:
            <ol>
              <li>If <a>state</a> is <a href="#dom-recordingstate-inactive">
              inactive</a>, throw an <code>InvalidStateError</code> DOMException
              and terminate these steps. Otherwise the UA MUST queue a task,
              using the DOM manipulation task source, that runs the following
              steps:
              <ol>
               <li>Set <a>state</a> to <a href="#dom-recordingstate-inactive">
               inactive</a> and stop gathering data.</li>
               <li>Let <var>blob</var> be the Blob of collected data so far and
               let <var>target</var> be the MediaRecorder context object, then
               <a href="#dfn-to-fire-a-blob-event">fire a blob event</a> named
               <code>dataavailable</code> at <var>target</var> with
               <var>blob</var>.</li>
               <li>
               <a href="https://dom.spec.whatwg.org/#concept-event-fire">Fire
               an event</a> named <code>stop</code> at <var>target</var>.</li>
              </ol>
              </li>
              <li>return <code>undefined</code>.</li>
            </ol>
            <div>
              <em>No parameters.</em>
            </div>
            <div>
              <em>Return type:</em> <code>void</code>
            </div>
          </dd>
          <dt><dfn><code>pause</code></dfn></dt>
          <dd>
            When a <code>MediaRecorder</code> object&#8217;s
            <code>pause()</code>method is invoked, the UA MUST run the following
            steps:
            <ol>
              <li>If <a>state</a> is <a href="#dom-recordingstate-inactive">
              inactive</a> throw an <code>InvalidStateError</code> DOMException
              and terminate these steps. Otherwise the UA MUST queue a task,
              using the DOM manipulation task source, that runs the following
              steps:
              <ol>
               <li>Set <a>state</a> to <a href="#dom-recordingstate-paused">
               paused</a>.</li>
               <li>Stop gathering data into <var>blob</var> (but keep it
               available so that recording can be resumed in the future).</li>
               <li>Let <var>target</var> be the MediaRecorder context object.
               <a href="https://dom.spec.whatwg.org/#concept-event-fire">Fire
               an event</a> named <code>pause</code> at <var>target</var>.</li>
               </ol>
              </li>
              <li>return <code>undefined</code>.</li>
            </ol>
            <div>
              <em>No parameters.</em>
            </div>
            <div>
              <em>Return type:</em> <code>void</code>
            </div>
          </dd>
          <dt><dfn><code>resume</code></dfn></dt>
          <dd>
            When a <code>MediaRecorder</code> object&#8217;s <code>resume()
            </code> method is invoked, the UA MUST run the following steps:
            <ol>
              <li>If <a>state</a> is <a href="#dom-recordingstate-inactive">
              inactive</a> throw an <code>InvalidStateError</code> DOMException
              and terminate these steps. Otherwise the UA MUST queue a task,
              using the DOM manipulation task source, that runs the following
              steps:
              <ol>
               <li>Set <a>state</a> to <a href="#dom-recordingstate-recording">
               recording</a>.</li>
               <li>Resume (or continue) gathering data into the current
               <var>blob</var>.</li>
               <li>Let <var>target</var> be the MediaRecorder context object.
               <a href="https://dom.spec.whatwg.org/#concept-event-fire">Fire
               an event</a> named <code>resume</code> at <var>target</var>.</li>
              </ol>
              </li>
              <li>return <code>undefined</code>.</li>
            </ol>
            <div>
              <em>No parameters.</em>
            </div>
            <div>
              <em>Return type:</em> <code>void</code>
            </div>
          </dd>
          <dt><dfn><code>requestData</code></dfn></dt>
          <dd>
            When a <code>MediaRecorder</code>object&#8217;s
            <code>requestData()</code> method is invoked, the UA MUST run the
            following steps:
            <ol>
              <li>If <a>state</a> is not <a href="#dom-recordingstate-recording">
              inactive</a> throw an <code>InvalidStateError</code> DOMException
              and terminate these steps. Otherwise the UA MUST queue a task,
              using the DOM manipulation task source, that runs the following
              steps:
              <ol>
               <li>Let <var>blob</var> be the Blob of collected data so far and
               let <var>target</var> be the MediaRecorder context object, then
               <a href="#dfn-to-fire-a-blob-event">fire a blob event</a> named
               <code>dataavailable</code> at <var>target</var> with
               <var>blob</var>.
               (Note that <var>blob</var> will be empty if no data has been
               gathered yet.)</li>
               <li>Create a new Blob and gather subsequent data into it.</li>
              </ol>
              </li>
              <li>return <code>undefined</code>.</li>
            </ol>
            <div>
              <em>No parameters.</em>
            </div>
            <div>
              <em>Return type:</em> <code>void</code>
            </div>
          </dd>
          <dt><dfn><code>isTypeSupported</code></dfn>, static</dt>
          <dd>
            Check to see whether a <code>MediaRecorder</code> can record in a
            specified MIME type. If true is returned from this method, it only
            indicates that the <code>MediaRecorder</code> implementation is
            capable of recording Blob objects for the specified MIME type.
            Recording may still fail if sufficient resources are not available
            to support the concrete media encoding. When this method is
            invoked, the User Agent must run the following steps:
            <ol class="method-algorithm">
              <li>If <code>type</code> is an empty string, then return true
              (note that this case is essentially equivalent to leaving up to
              the UA the choice of container and codecs on constructor).</li>
              <li>If <code>type</code> does not contain a valid MIME type
              string, then return false.</li>
              <li>If <code>type</code> contains a media type or media subtype
              that the MediaRecorder does not support, then return false.</li>
              <li>If <code>type</code> contains a media container that the
              MediaSource does not support, then return false.</li>
              <li>If <code>type</code> contains a codec that the MediaSource
              does not support, then return false.</li>
              <li>If the MediaRecorder does not support the specified
              combination of media type/subtype, codecs and container then
              return false.</li>
              <li>Return true.</li>
            </ol>
            <table class="parameters">
              <tbody>
                <tr>
                  <th>Parameter</th>
                  <th>Type</th>
                  <th>Nullable</th>
                  <th>Optional</th>
                  <th>Description</th>
                </tr>
                <tr>
                  <td class="prmName">type</td>
                  <td class="prmType"><code>DOMString</code></td>
                  <td class="prmNullFalse"><span role="img" aria-label=
                  "False">&#10008;</span></td>
                  <td class="prmOptFalse"><span role="img" aria-label=
                  "False">&#10008;</span></td>
                  <td class="prmDesc">
                    A <a href="https://tools.ietf.org/html/rfc2046">MIME
                    Type</a>, including parameters, specifying a container
                    and/or codec formats for recording.
                  </td>
                </tr>
              </tbody>
            </table>
            <div>
              <em>Return type:</em> <code>boolean</code>
            </div>
          </dd>
        </dl>
      </section>
    </div>
    <section>
      <h2>Data handling</h2>
        <p><dfn data-dfn-type="dfn"
        data-lt="fire a blob event">To fire a blob event</dfn> with a
        <a href="https://www.w3.org/TR/FileAPI/#blob"><code>Blob</code></a>
        <var>blob</var> means
        <a href="https://dom.spec.whatwg.org/#concept-event-fire">firing
        an event</a> at <var>target</var> using a <a>BlobEvent</a> with its
        <code>data</code> attribute initialized to <var>blob</var>.
       </p>

        <div class="note">
        Usually <var>blob</var> will be the data gathered by the UA after the
        last transition to <a href="#dom-recordingstate-recording">recording
        </a> <a href="#dom-mediarecorder-state">state</a>.
        </div>
    </section>

    <section id="MediaRecorderOptions">
      <h3>MediaRecorderOptions</h3>
      <div>
        <pre class="idl">
          dictionary MediaRecorderOptions {
            DOMString mimeType;
            unsigned long audioBitsPerSecond;
            unsigned long videoBitsPerSecond;
            unsigned long bitsPerSecond;
          };
        </pre>
        <section>
          <h2>Dictionary <a class="idlType">MediaRecorderOptions</a>
          Members</h2>
          <dl data-link-for="MediaRecorderOptions" data-dfn-for=
          "MediaRecorderOptions" class="dictionary-members">

            <dt><dfn><code>mimeType</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>The container and codec format(s) [[!RFC2046]] for the
            recording, which may include any parameters that are defined for the
            format. If the UA does not support the format or any of the
            parameters specified, it MUST throw a <code>NotSupportedError</code>
            DOMException. If this paramater is not specified, the UA will use a
            platform-specific default format. The container format, whether
            passed in to the constructor or defaulted, will be used as the value
            of the <code>mimeType</code> attribute.

            <div class="note"> <code><a>mimeType</a></code> specifies the media
            type and container format for the recording via a type/subtype
            combination, with the codecs and/or profiles parameters [[RFC6381]]
            specified where ambiguity might arise. Individual codecs might have
            further optional specific parameters. </div></dd>

            <dt><dfn><code>audioBitsPerSecond</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>Aggregate target bits per second for encoding of the Audio
            track(s), if any. This is a hint for the encoder and the value
            might be surpassed, not achieved, or only be achieved over a long
            period of time.</dd>

            <dt><dfn><code>videoBitsPerSecond</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>Aggregate target bits per second for encoding of the Video
            track(s), if any. This is a hint for the encoder and the value
            might be surpassed, not achieved, or only be achieved over a long
            period of time.</dd>

            <dt><dfn><code>bitsPerSecond</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>Aggregate target bits per second for encoding of all Video and
            Audio Track(s) present. This parameter will limit either
            <code>audioBitsPerSecond</code>, <code>videoBitsPerSecond</code> or
            their sum, whichever is present, and might be distributed among the
            present track encoders as the UA sees fit. This parameter is a hint
            for the encoder(s) and the total value might be surpassed, not
            achieved, or only be achieved over a long period of time.</dd>
          </dl>
        </section>
      </div>
    </section>
    <section id="RecordingState">
      <h3>RecordingState</h3>
      <div>
        <pre class="idl">
          enum RecordingState {
            "inactive",
            "recording",
            "paused"
          };
        </pre>
        <table data-link-for="RecordingState" data-dfn-for="RecordingState"
        class="simple">
          <tbody>
            <tr>
              <th colspan="2">Enumeration description</th>
            </tr>
            <tr>
              <td><dfn><code id=
              "idl-def-RecordingState.inactive">inactive</code></dfn></td>
              <td>Recording is not occuring. (Either it has not been started or
              it has been stopped.).</td>
            </tr>
            <tr>
              <td><dfn><code id=
              "idl-def-RecordingState.recording">recording</code></dfn></td>
              <td>Recording has been started and the UA is capturing
              data..</td>
            </tr>
            <tr>
              <td><dfn><code id=
              "idl-def-RecordingState.paused">paused</code></dfn></td>
              <td>Recording has been started, then paused, and not yet stopped
              or resumed.</td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>
  </section>
  <section id="blob-event">
    <h2>Blob Event</h2>
    <div>
      <pre class="idl">
        [Constructor (DOMString type, BlobEventInit eventInitDict)]
        interface BlobEvent : Event {
          [SameObject] readonly attribute Blob data;
          readonly attribute DOMHighResTimeStamp timecode;
        };
      </pre>
      <section>
        <h2>Constructors</h2>
        <dl data-link-for="BlobEvent" data-dfn-for="BlobEvent" class=
        "constructors">
          <dt><dfn><code>BlobEvent</code></dfn></dt>
          <dd>
            <table class="parameters">
              <tbody>
                <tr>
                  <th>Parameter</th>
                  <th>Type</th>
                  <th>Nullable</th>
                  <th>Optional</th>
                  <th>Description</th>
                </tr>
                <tr>
                  <td class="prmName">type</td>
                  <td class="prmType"><code>DOMString</code></td>
                  <td class="prmNullFalse"><span role="img" aria-label=
                  "False">&#10008;</span></td>
                  <td class="prmOptFalse"><span role="img" aria-label=
                  "False">&#10008;</span></td>
                  <td class="prmDesc">
                    Associated <a href=
                    "https://dom.spec.whatwg.org/#interface-event">Event
                    type.</a>
                  </td>
                </tr>
                <tr>
                  <td class="prmName">eventInitDict</td>
                  <td class="prmType"><code>BlobEventInit</code></td>
                  <td class="prmNullFalse"><span role="img" aria-label=
                  "False">&#10008;</span></td>
                  <td class="prmOptFalse"><span role="img" aria-label=
                  "False">&#10008;</span></td>
                  <td class="prmDesc">An initializer whose <code>data</code>
                  field will be used to initialize the attribute of the same
                  name.</td>
                </tr>
              </tbody>
            </table>
          </dd>
        </dl>
      </section>
      <section>
        <h2>Attributes</h2>
        <dl data-link-for="BlobEvent" data-dfn-for="BlobEvent" class=
        "attributes">
          <dt><dfn><code>data</code></dfn> of type <span class="idlAttrType">
          <a href="https://www.w3.org/TR/FileAPI/#blob">Blob</a></span>,
          readonly</dt>
          <dd>The encoded blob. Its
          <a href="https://www.w3.org/TR/FileAPI/#dfn-type">
          type</a> attribute correlates to the selected
          <a href="#dom-mediarecorder-mimetype">mimeType</a>.</dd>

          <dt><dfn><code>timecode</code></dfn> of type <span class="idlAttrType">
          <a href="https://www.w3.org/TR/hr-time-2/#dom-domhighrestimestamp">
          DOMHighResTimeStamp</a></span>, readonly</dt>
          <dd>The difference between the timestamp of the first chunk in
          <var>data</var> and the timestamp of the first chunk in the first
          <a>BlobEvent</a> produced by this recorder.
          Note that the <var>timecode</var> in the first produced
          <a>BlobEvent</a> does not need to be zero.
          </dd>
        </dl>
      </section>
    </div>
    <h3>BlobEventInit</h3>
    <div>
      <pre class="idl">
        dictionary BlobEventInit {
          required Blob data;
          DOMHighResTimeStamp timecode;
        };
      </pre>
      <section>
        <h2>Dictionary <a class="idlType">BlobEventInit</a> Members</h2>
        <dl data-link-for="BlobEventInit" data-dfn-for="BlobEventInit" class=
        "dictionary-members">
          <dt><dfn><code>data</code></dfn> of type <span class=
          "idlMemberType"><a>Blob</a></span>, required</dt>
          <dd>A Blob object containing the data to deliver via this event.</dd>

          <dt><dfn><code>timecode</code></dfn> of type <span class="idlMemberType">
          <a href="https://www.w3.org/TR/hr-time-2/#dom-domhighrestimestamp">
          DOMHighResTimeStamp</a></span>, optional</dt>
          <dd>The timecode to be used in initializing <a>BlobEvent</a>.</dd>

        </dl>
      </section>
    </div>
  </section>
  <section id="error-handling">
    <h2>Error Handling</h2>
    <section id="general-principles"  class="informative">
      <h3>General Principles</h3>

      <p>The UA will throw a <a
      href="https://heycam.github.io/webidl/#idl-DOMException">DOMException</a>
      ([[!DOM]]) when the error can be detected at the time that the call is
      made. In all other cases the UA will
      <a href="https://dom.spec.whatwg.org/#concept-event-fire">fire an event</a>
      named <a><code>ErrorEvent</code></a>.
      If recording has been started and not yet stopped when the error occurs,
      let <var>blob</var> be the Blob of collected data so far; after raising
      the error, the UA will <a href="#dfn-to-fire-a-blob-event">fire a
      dataavailable event</a> with <var>blob</var>; immediately after
      the UA will then
      <a href="https://dom.spec.whatwg.org/#concept-event-fire">fire an event</a>
      named <code>stop</code>.
      The UA may set platform-specific limits, such as those for the minimum and
      maximum Blob size that it will support, or the number of Tracks it will
      record at once.
      It will signal a fatal error if these limits are exceeded.</p>

    </section>
    <section>
      <h3>ErrorEvent</h3>
      <p>The <a>ErrorEvent</a> interface is defined for cases when an event is raised
      that could have been caused by an error.</p>
      <p><dfn data-dfn-type="dfn"
      data-lt="firing an error event">To fire an error event</dfn> named
      <var>e</var> with a <code>DOMException</code> named <var>error</var> means
      that an event with the name <var>e</var>, which does not bubble (except
      where otherwise stated) and is not cancelable (except where otherwise
      stated), and which uses the <code><a>ErrorEvent</a></code> interface with
      the <code><a data-link-for= "ErrorEvent">error</a></code> attribute set to
      <var>error</var>, must be created and
      <a href="https://dom.spec.whatwg.org/#concept-event-dispatch">dispatched
      </a> at the given target. If no <code>DOMException</code> object is
      specified, the <code><a data-link-for="ErrorEvent">error</a></code>
      attribute defaults to null.</p>
      <div>
        <pre class="idl">
          [Exposed=Window, Constructor (DOMString type, ErrorEventInit eventInitDict)]
          interface ErrorEvent : Event {
            readonly attribute DOMException? error;
          };
        </pre>
        <section>
          <h2>Constructors</h2>
          <dl data-link-for="ErrorEvent" data-dfn-for="ErrorEvent" class=
          "constructors">
            <dt><code>ErrorEvent</code></dt>
            <dd>
              Constructs a new <code><a>ErrorEvent</a></code>.
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">type</td>
                    <td class="prmType"><code>DOMString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">eventInitDict</td>
                    <td class="prmType"><code>ErrorEventInit</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="ErrorEvent" data-dfn-for="ErrorEvent" class=
          "attributes">
            <dt><dfn><code>error</code></dfn> of type <span class=
            "idlAttrType"><a>Error</a></span>, readonly , nullable</dt>
            <dd>If the event was raised because of an error, this attribute MAY
            be set to that error object.</dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">
          dictionary ErrorEventInit : EventInit {
            Error? error = null;
          };
        </pre>
        <section>
          <h2>Dictionary <a class="idlType">ErrorEventInit</a> Members</h2>
          <dl data-link-for="ErrorEventInit" data-dfn-for="ErrorEventInit"
          class="dictionary-members">
            <dt><dfn><code>error</code></dfn> of type <span class=
            "idlMemberType"><a>Error</a></span>, nullable, defaulting to
            <code>null</code></dt>
            <dd>If the event was raised because of an error, this attribute MAY
            be set to that error object.</dd>
          </dl>
        </section>
      </div>
    </section>
    <section id="exception-summary" class="informative">
      <h3>Exception summary</h3>
      <p>Each of the exceptions defined in this document is a <a href=
      "http://www.w3.org/TR/2012/WD-dom-20121206/#exception-domexception"><code>
      DOMException</code></a> with a specific type. The exception types and
      properties such as code value are defined in [[!WEBIDL]].</p>
      <table class="vert">
        <thead>
          <tr>
            <th>Name</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>InvalidStateError</code></td>
            <td>An operation was called on an object on which it is not allowed
            or at a time when it is not allowed, or if a request is made on a
            source object that has been deleted or removed.</td>
          </tr>
          <tr>
            <td><code>NotSupportedError</code></td>
            <td>
              A <a><code>MediaRecorder</code></a> could not be created due to
              unsupported options (e.g. MIME type) specification. User agents
              should provide as much additional information as possible in the
              <code>message</code> attribute.
            </td>
          </tr>
          <tr>
            <td><code>SecurityError</code></td>
            <td>The isolation properties of the MediaStream do not allow the
            MediaRecorder access to it.</td>
          </tr>
        </tbody>
      </table>
    </section>
  </section>
  <section id="event-summary" class="informative">
    <h2>Event summary</h2>
    <p>The following additional events fire on <code><a>MediaRecorder</a></code>
    objects:</p>
    <table class="vert">
      <thead>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th><a href="https://dom.spec.whatwg.org/#concept-event-fire">Fired
          </a> when...</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><dfn id="event-mediarecorder-start"><code>start</code></dfn></td>
          <td><code>Event</code></td>
          <td>The UA has started recording data from the MediaStream.</td>
        </tr>
        <tr>
          <td><dfn id="event-mediarecorder-stop"><code>stop</code></dfn></td>
          <td><code>Event</code></td>
          <td>The UA has stopped recording data from the MediaStream.</td>
        </tr>
        <tr>
          <td><dfn id=
          "event-mediarecorder-dataavailable"><code>dataavailable</code></dfn></td>
          <td>
            <a><code>BlobEvent</code></a>
          </td>
          <td>The UA generates this even to return data to the application. The
          'data' attribute of this event contains a Blob of recorded data.</td>
        </tr>
        <tr>
          <td><dfn id="event-mediarecorder-pause"><code>pause</code></dfn></td>
          <td><code>Event</code></td>
          <td>The UA has paused recording data from the MediaStream.</td>
        </tr>
        <tr>
          <td><dfn id=
          "event-mediarecorder-resume"><code>resume</code></dfn></td>
          <td><code>Event</code></td>
          <td>The UA has resumed recording data from the MediaStream.</td>
        </tr>
        <tr>
          <td><dfn id=
          "event-mediarecorder-ErrorEvent"><code>ErrorEvent</code></dfn></td>
          <td><code>EventError</code></td>
          <td>An error has occurred, e.g. out of memory or a modification to
          the <code>stream</code> has occurred that makes it impossible to
          continue recording (e.g. a Track has been added to or removed from
          the said <code>stream</code> while recording is occurring).</td>
        </tr>
      </tbody>
    </table>
  </section>


  <section id="examples" class="informative">
  <h2>Examples</h2>

  <div class="note">
  Slightly modified versions of these examples can be found in e.g. <a
   href="https://codepen.io/collection/XjkNbN/">this codepen collection</a>.
   </div>

  <section>
  <h3>Check for <code>MediaRecorder</code> and <code>MIMEType</code>.</h3>

  <div class="note">
  The following example can also be found in e.g. <a
  href="https://codepen.io/miguelao/pen/edqNab?editors=0010">this codepen</a>
  with minimal modifications.
  </div>

  <pre class='example'>
  if (window.MediaRecorder == undefined) {
    console.error('MediaRecorder not supported, boo');
  } else {
    var contentTypes = ["video/webm",
                        "video/webm;codecs=vp8",
                        "audio/webm",
                        "video/mp4;codecs=h264",
                        "video/invalid"];
    contentTypes.forEach(contentType => {
      console.log(contentType + ' is '
          + (MediaRecorder.isTypeSupported(contentType) ?
              'supported' : 'NOT supported '));
    });
  }
  </pre>
  </section>

  <section>
  <h3>Recording webcam video and audio</h3>
  <div class="note">
  The following example can also be found in e.g. <a
  href="https://codepen.io/miguelao/pen/wzVMJb?editors=0010">this codepen</a>
  with minimal modifications.
  </div>

  <pre class='example'>
  &lt;html>
  &lt;body>
  &lt;video autoplay/>
  &lt;script>
    var recordedChunks = [];

    function gotMedia(stream) {
      var video = document.querySelector('video');
      video.src = URL.createObjectURL(stream);
      var recorder = null;
      try {
        recorder = new MediaRecorder(stream, {mimeType : "video/webm"});
      } catch (e) {
        console.error('Exception while creating MediaRecorder: ' + e);
        return;
      }

      recorder.ondataavailable = (event) => {
        console.log(' Recorded chunk of size ' + event.data.size + "B");
        recordedChunks.push(event.data);
      };

      recorder.start(100);
    }

    navigator.mediaDevices.getUserMedia({video: true , audio: true})
        .then(gotMedia)
        .catch(e => { console.error('getUserMedia() failed: ' + e); });
  &lt;/script>
  &lt;/body>
  &lt;/html>
  </pre>

  <div class="note">
  <code>recordedChunks</code> can be saved to a file using e.g. the function
  <code>download()</code> in the <a
  href="https://developers.google.com/web/updates/2016/01/mediarecorder">
  MediaRecorder Web Fundamentals article</a>.
  </div>

  </section>

  </section>
</body>
</html>
