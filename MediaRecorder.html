<!DOCTYPE html>
<html>
<head>
  <link href="MediaRecorder.css" rel="stylesheet" type="text/css">
  <title>MediaStream Recording</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <script type="text/javascript" src=
  'https://www.w3.org/Tools/respec/respec-w3c-common' class='remove'>
  </script>
  <script type="text/javascript" src="MediaRecorder.js" class='remove'>
  // &lt;!-- keep this comment --&gt; //
  </script>
</head>
<body>
  <section id="abstract">
    <p>This document defines a recording API for use with MediaStreams as
    defined in [[!GETUSERMEDIA]]</p>
  </section>
  <section id="sotd">
    <p>This document is not complete. It is subject to major changes and, while
    early experimentations are encouraged, it is therefore not intended for
    implementation. The Media Capture Task Force expects this specification to
    evolve significantly based on:</p>
    <ul>
      <li>Privacy issues that arise when capturing media.</li>
      <li>Technical discussions within the task force.</li>
      <li>Experience gained through early experimentations.</li>
      <li>Feedback received from other groups and individuals.</li>
    </ul>
  </section>
  <section id="overview" class="informative">
    <h2>Overview</h2>

    <p>This API attempts to make basic recording very simple, while still
    allowing for more complex use cases. In the simplest case, the application
    instatiates a <code><a>MediaRecorder</a></code> object, calls <a href="#dom-
    mediarecorder-start">start()</a> and then calls <a href="#dom-mediarecorder-
    start">stop()</a> or waits for the MediaStreamTrack(s) to be ended. The
    contents of the recording will be made available in the platform's default
    encoding via the <a href="#dom-mediarecorder-ondataavailable">
    ondataavailable</a> event. Functions are available to query the platform's
    available set of encodings, and to select the desired ones if the author
    wishes. The application can also choose how much data it wants to receive at
    one time. By default a <a
    href="https://www.w3.org/TR/FileAPI/#blob"><code>Blob</code></a> containing
    the entire recording is returned when the recording finishes. However the
    application can choose to receive smaller buffers of data at regular
    intervals.</p>

  </section>
  <section id="not-conformance" class="informative">
    <h2>Conformance</h2>
    <p>This specification defines conformance criteria that apply to a single
    product: the <dfn>user agent</dfn> that implements the interfaces that it
    contains.</p>
    <p>Conformance requirements phrased as algorithms or specific steps may be
    implemented in any manner, so long as the end result is equivalent to the
    behavior specified in this document.</p>
    <p>Implementations that use ECMAScript to implement the APIs defined in
    this specification must implement them in a manner consistent with the
    ECMAScript Bindings defined in the Web IDL specification [[!WEBIDL]], as
    this specification uses that specification and terminology.</p>
    <p></p>
  </section>
  <section id="MediaRecorderAPI">
    <h2>Media Recorder API</h2>
    <div>
      <pre class="idl">
      [ Constructor (MediaStream stream, optional MediaRecorderOptions options)]
interface MediaRecorder : EventTarget {
    readonly        attribute MediaStream    stream;
    readonly        attribute DOMString      mimeType;
    readonly        attribute RecordingState state;
                    attribute EventHandler   onstart;
                    attribute EventHandler   onstop;
                    attribute EventHandler   ondataavailable;
                    attribute EventHandler   onpause;
                    attribute EventHandler   onresume;
                    attribute EventHandler   onerror;
                    attribute boolean        ignoreMutedMedia;
    readonly        attribute unsigned long  videoBitsPerSecond;
    readonly        attribute unsigned long  audioBitsPerSecond;
    void           start (optional long timeslice);
    void           stop ();
    void           pause ();
    void           resume ();
    void           requestData ();
    static boolean isTypeSupported (DOMString type);
};</pre>
      <section>
        <h2>Constructors</h2>
        <dl data-link-for="MediaRecorder" data-dfn-for="MediaRecorder" class=
        "constructors">
          <dt><dfn><code>MediaRecorder</code></dfn></dt>
          <dd>
            <table class="parameters">
              <tbody>
                <tr>
                  <th>Parameter</th>
                  <th>Type</th>
                  <th>Nullable</th>
                  <th>Optional</th>
                  <th>Description</th>
                </tr>
                <tr>
                  <td class="prmName">stream</td>
                  <td class="prmType"><code>MediaStream</code></td>
                  <td class="prmNullFalse"><span role="img" aria-label=
                  "False">&#10008;</span></td>
                  <td class="prmOptFalse"><span role="img" aria-label=
                  "False">&#10008;</span></td>
                  <td class="prmDesc">The MediaStream to be recorded. This will
                  be the value of the <code>stream</code> attribute. See
                  [[!GETUSERMEDIA]] for the definition of MediaStream.</td>
                </tr>
                <tr>
                  <td class="prmName">options</td>
                  <td class="prmType"><code><a>MediaRecorderOptions</a></code></td>
                  <td class="prmNullFalse"><span role="img" aria-label=
                  "False">&#10008;</span></td>
                  <td class="prmOptTrue"><span role="img" aria-label=
                  "True">&#10004;</span></td>
                  <td class="prmDesc">A dictionary of options to for the UA
                  instructing how the recording will take part.
                  <code>options.mimeType</code>, if present, will become the
                  value of <code>mimeType</code> attribute.</td>
                </tr>
              </tbody>
            </table>
          </dd>
        </dl>
      </section>
      <section>
        <h2>Attributes</h2>
        <dl data-link-for="MediaRecorder" data-dfn-for="MediaRecorder" class=
        "attributes">
          <dt><dfn><code>stream</code></dfn> of type <span class=
          "idlAttrType"><a>MediaStream</a></span>, readonly</dt>
          <dd>The MediaStream to be recorded.</dd>

          <dt><dfn><code>mimeType</code></dfn> of type <span class=
          "idlAttrType"><a>DOMString</a></span>, readonly</dt>

          <dd>The MIME type [[!RFC2046]] that has been selected as the container
          for recording. This entry includes all the parameters to the base
          <code>mimeType</code>. The UA should be able to play back any of the
          MIME types it supports for recording. For example, it should be able
          to display a video recording in the HTML &lt;video&gt; tag. The
          default value for this property is platform-specific.

          <div class="note"> <code><a>mimeType</a></code> specifies the media
          type and container format for the recording via a type/subtype
          combination, with the codecs and/or profiles parameters [[RFC6381]]
          specified where ambiguity might arise. Individual codecs might have
          further optional specific parameters. </div></dd>

          <dt><dfn><code>state</code></dfn> of type <span class=
          "idlAttrType"><a>RecordingState</a></span>, readonly</dt> <dd>The
          current state of the MediaRecorder object. When the MediaRecorder is
          created, the UA MUST set this attribute to <code>inactive</code>.</dd>

          <dt><dfn><code>onstart</code></dfn> of type <span class=
          "idlAttrType"><a>EventHandler</a></span></dt>
          <dd>Called to handle the start event.</dd>

          <dt><dfn><code>onstop</code></dfn> of type <span class=
          "idlAttrType"><a>EventHandler</a></span></dt>
          <dd>Called to handle the stop event.</dd>

          <dt><dfn><code>ondataavailable</code></dfn> of type <span class=
          "idlAttrType"><a>EventHandler</a></span></dt>
          <dd>Called to handle the dataavailable event. The <a
          href="https://www.w3.org/TR/FileAPI/#blob"><code>Blob</code></a>
          [[!FILE-API]] of recorded data is contained in this event and can be
          accessed via the 'data' attribute.</dd>

          <dt><dfn><code>onpause</code></dfn> of type <span class=
          "idlAttrType"><a>EventHandler</a></span></dt>
          <dd>Called to handle the pause event.</dd>

          <dt><dfn><code>onresume</code></dfn> of type <span class=
          "idlAttrType"><a>EventHandler</a></span></dt>
          <dd>Called to handle the resume event.</dd>

          <dt><dfn><code>onerror</code></dfn> of type <span class=
          "idlAttrType"><a>EventHandler</a></span></dt>
          <dd>Called to handle an <a>ErrorEvent</a>.</dd>

          <dt><dfn><code>ignoreMutedMedia</code></dfn> of type <span class=
          "idlAttrType"><a>boolean</a></span></dt>
          <dd>If this attribute is set to <code>true</code>, MediaRecorder will
          not record any input when a given source <a
          href="https://www.w3.org/TR/mediacapture-streams/#mediastreamtrack">
          <code>MediaStreamTrack</code></a> is muted. If this attribute is
          <code>false</code>, MediaRecorder will record silence (for audio) and
          black frames (for video) when the input MediaStream is muted. When the
          MediaRecorder is created, the UA MUST set this attribute to
          <code>false</code>.</dd>

          <dt><dfn><code>videoBitsPerSecond</code></dfn> of type <span class=
          "idlAttrType"><a>unsigned long</a></span>, readonly</dt>
          <dd>The value of the Video encoding target bit rate that was passed to
          the Platform (potentially truncated, rounded, etc), or the calculated
          one if the user has specified <code>bitsPerSecond</code>.</dd>

          <dt><dfn><code>audioBitsPerSecond</code></dfn> of type <span class=
          "idlAttrType"><a>unsigned long</a></span>, readonly</dt>
          <dd>The value of the Audio encoding target bit rate that was passed to
          the Platform (potentially truncated, rounded, etc), or the calculated
          one if the user has specified <code>bitsPerSecond</code>.</dd>
        </dl>
      </section>
      <section>
        <h2>Methods</h2>
        <dl data-link-for="MediaRecorder" data-dfn-for="MediaRecorder" class=
        "methods">
          <dt><dfn><code>start</code></dfn></dt>
          <dd>
            When a <code>MediaRecorder</code> object&#8217;s
            <code>start()</code> method is invoked, the UA MUST run the
            following steps:
            <ol>
              <li>Let <var>timeslice</var> be the method's first argument, if
              provided, or <code>undefined</code>.</li>
              <li>If <code>state</code> is not <code>inactive</code>, throw an
              <code>InvalidStateError</code> DOMException and abort these
              steps.</li>
              <li>If the stream's isolation properties disallow access from
              this MediaRecorder, throw a <code>SecurityError</code>
              DOMException and abort these steps.</li>
              <li>Set <code>state</code> to "recording", and run the following
              steps in parallel:
                <ol>

                  <li>Once media becomes available from one or more of the
                  stream's tracks, start gathering the data into a Blob (see
                  [[!FILE-API]]), and queue a task, using the DOM manipulation
                  task source, to fire an event named <code>start</code>.</li>

                  <li>If at any point the stream's isolation properties change
                  so that MediaRecorder is no longer allowed access to it, the
                  UA MUST immediately stop gathering data, discard any data that
                  it has gathered, and queue a task, using the DOM manipulation
                  task source, that <a>fires an error event</a> with the name
                  <code>SecurityError</code>, immediately followed by a <code>
                  stop</code> event. </li>

                  <li>If the UA at any point is unable to continue gathering
                  data for reasons other than isolation properties, it MUST stop
                  gathering data, let <var>blob</var> be the Blob of collected
                  data, and queue a task, using the DOM manipulation task
                  source, that <a>fires an error event</a> with the name
                  <code>UnknownError</code>, followed by a
                  <code>dataavailable</code> event containing <var>blob</var>,
                  followed by a <code>stop</code> event. </li>

                  <li>If <var>timeslice</var> is not <code>undefined</code>,
                  then once a minimum of <var>timeslice</var> milliseconds of
                  data have been collected, or some minimum time slice imposed
                  by the UA, whichever is greater, let <var>blob</var> be the
                  Blob of collected data, start gathering a new Blob of data,
                  and queue a task, using the DOM manipulation task source, that
                  fires a <code>dataavailable</code> event containing
                  <var>blob</var>. Note that an <code>undefined</code> value of
                  <var>timeslice</var> will be understood as the largest
                  <code>long</code> value.</li>

                  <li>If all recorded tracks become <a href=
                  "http://www.w3.org/TR/mediacapture-streams/#track-ended">ended</a>
                  [[!GETUSERMEDIA]], then stop gathering data, let
                  <var>blob</var> be the Blob of collected data, and queue a
                  task, using the DOM manipulation task source, that runs the
                  following steps:
                    <ol>
                      <li>set <code>recording</code> to "inactive".</li>
                      <li>Fire an event named <code>dataavailable</code>
                      containing <var>blob</var>.</li>
                      <li>Fire an event named <code>stop</code>.</li>
                    </ol>
                  </li>

                </ol>
              </li>
              <li>return <code>undefined</code>.</li>
            </ol>
            <p>Note that <code>stop()</code>, <code>requestData()</code>, and
            <code>pause()</code> also affect the recording behavior.</p>

            <p>The UA MUST record the MediaStream in such a way that the
            original Tracks can be retrieved at playback time. When multiple
            Blobs are returned (because of <code>timeslice</code> or
            <code>requestData</code>), the individual Blobs need not be
            playable, but the combination of all the Blobs from a completed
            recording MUST be playable.</p>

            <p> If any Track within the MediaStream is muted at any time (i.e.,
            if its <code>muted</code> flag is set to <code>true</code>), the UA
            MUST insert black frames or silence until the Track is unmuted, or
            record nothing, depending on the value of
            <a>ignoreMutedMedia</a>.</p>

            <table class="parameters">
              <tbody>
                <tr>
                  <th>Parameter</th>
                  <th>Type</th>
                  <th>Nullable</th>
                  <th>Optional</th>
                  <th>Description</th>
                </tr>
                <tr>
                  <td class="prmName">timeslice</td>
                  <td class="prmType"><code>long</code></td>
                  <td class="prmNullFalse"><span role="img" aria-label=
                  "False">&#10008;</span></td>
                  <td class="prmOptTrue"><span role="img" aria-label=
                  "True">&#10004;</span></td>
                  <td class="prmDesc">The minimum number of milliseconds of data
                  to return in a single Blob.</td>
                </tr>
              </tbody>
            </table>
            <div>
              <em>Return type:</em> <code>void</code>
            </div>
          </dd>
          <dt><dfn><code>stop</code></dfn></dt>
          <dd>
            When a <code>MediaRecorder</code> object&#8217;s <code>stop</code>
            method is invoked, the UA MUST queue a task, using the DOM
            manipulation task source, that runs the following steps:
            <ol>
              <li>If <code>state</code> is <code>inactive</code>, throw an
              <code>InvalidStateError</code> DOMException and terminate these
              steps. Otherwise:</li>
              <li>Set <code>state</code> to <code>inactive</code> and stop
              gathering data.</li>
              <li>Fire an event named <code>dataavailable</code> containing the
              Blob of data that has been gathered.</li>
              <li>Fire an event named <code>stop</code>.</li>
            </ol>
            <div>
              <em>No parameters.</em>
            </div>
            <div>
              <em>Return type:</em> <code>void</code>
            </div>
          </dd>
          <dt><dfn><code>pause</code></dfn></dt>
          <dd>
            When a <code>MediaRecorder</code> object&#8217;s
            <code>pause()</code>method is invoked, the UA MUST queue a task,
            using the DOM manipulation task source, that runs the following
            steps:
            <ol>
              <li>If <code>state</code> is "inactive" throw an
              <code>InvalidStateError</code> DOMException and terminate these
              steps. Otherwise:</li>
              <li>Set <code>state</code> to "paused".</li>
              <li>Stop gathering data into its current Blob (but keep the Blob
              available so that recording can be resumed in the future).</li>
              <li>Fire an event named <code>pause</code>.</li>
            </ol>
            <div>
              <em>No parameters.</em>
            </div>
            <div>
              <em>Return type:</em> <code>void</code>
            </div>
          </dd>
          <dt><dfn><code>resume</code></dfn></dt>
          <dd>
            When a <code>MediaRecorder</code> object&#8217;s
            <code>resume()</code> method is invoked, the UA MUST queue a task,
            using the DOM manipulation task source, that runs the following
            steps:
            <ol>
              <li>If <code>state</code> is "inactive" throw an
              <code>InvalidStateError</code> DOMException and terminate these
              steps. Otherwise:</li>
              <li>Set <code>state</code> to "recording".</li>
              <li>Resume (or continue) gathering data into its current
              Blob.</li>
              <li>Fire an event named <code>resume</code>.</li>
            </ol>
            <div>
              <em>No parameters.</em>
            </div>
            <div>
              <em>Return type:</em> <code>void</code>
            </div>
          </dd>
          <dt><dfn><code>requestData</code></dfn></dt>
          <dd>
            When a <code>MediaRecorder</code>object&#8217;s
            <code>requestData()</code> method is invoked, the UA MUST queue a
            task, using the DOM manipulation task source, that runs the
            following steps:
            <ol>
              <li>If <code>state</code> is not "recording" throw an
              <code>InvalidStateError</code> DOMException and terminate these
              steps. Otherwise:</li>
              <li>Fire an event named <code>dataavailable</code> containing the
              current Blob of saved data. (Note that this Blob will be empty if
              no data has been gathered yet.)</li>
              <li>Create a new Blob and gather subsequent data into it.</li>
            </ol>
            <div>
              <em>No parameters.</em>
            </div>
            <div>
              <em>Return type:</em> <code>void</code>
            </div>
          </dd>
          <dt><dfn><code>isTypeSupported</code></dfn>, static</dt>
          <dd>
            Check to see whether a <code>MediaRecorder</code> can record in a
            specified MIME type. If true is returned from this method, it only
            indicates that the <code>MediaRecorder</code> implementation is
            capable of recording Blob objects for the specified MIME type.
            Recording may still fail if sufficient resources are not available
            to support the concrete media encoding. When this method is
            invoked, the User Agent must run the following steps:
            <ol class="method-algorithm">
              <li>If <code>type</code> is an empty string, then return true
              (note that this case is essentially equivalent to leaving up to
              the UA the choice of container and codecs on constructor).</li>
              <li>If <code>type</code> does not contain a valid MIME type
              string, then return false.</li>
              <li>If <code>type</code> contains a media type or media subtype
              that the MediaRecorder does not support, then return false.</li>
              <li>If <code>type</code> contains a media container that the
              MediaSource does not support, then return false.</li>
              <li>If <code>type</code> contains a codec that the MediaSource
              does not support, then return false.</li>
              <li>If the MediaRecorder does not support the specified
              combination of media type/subtype, codecs and container then
              return false.</li>
              <li>Return true.</li>
            </ol>
            <table class="parameters">
              <tbody>
                <tr>
                  <th>Parameter</th>
                  <th>Type</th>
                  <th>Nullable</th>
                  <th>Optional</th>
                  <th>Description</th>
                </tr>
                <tr>
                  <td class="prmName">type</td>
                  <td class="prmType"><code>DOMString</code></td>
                  <td class="prmNullFalse"><span role="img" aria-label=
                  "False">&#10008;</span></td>
                  <td class="prmOptFalse"><span role="img" aria-label=
                  "False">&#10008;</span></td>
                  <td class="prmDesc">
                    A <a href="https://tools.ietf.org/html/rfc2046">MIME
                    Type</a>, including parameters, specifying a container
                    and/or codec formats for recording.
                  </td>
                </tr>
              </tbody>
            </table>
            <div>
              <em>Return type:</em> <code>boolean</code>
            </div>
          </dd>
        </dl>
      </section>
    </div>
    <section id="MediaRecorderOptions">
      <h3>MediaRecorderOptions</h3>
      <div>
        <pre class="idl">
          dictionary MediaRecorderOptions {
            DOMString     mimeType;
            unsigned long audioBitsPerSecond;
            unsigned long videoBitsPerSecond;
            unsigned long bitsPerSecond;
          };
        </pre>
        <section>
          <h2>Dictionary <a class="idlType">MediaRecorderOptions</a>
          Members</h2>
          <dl data-link-for="MediaRecorderOptions" data-dfn-for=
          "MediaRecorderOptions" class="dictionary-members">

            <dt><dfn><code>mimeType</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>The container and codec format(s) [[!RFC2046]] for the
            recording, which may include any parameters that are defined for the
            format. If the UA does not support the format or any of the
            parameters specified, it MUST throw a <code>NotSupportedError</code>
            DOMException. If this paramater is not specified, the UA will use a
            platform-specific default format. The container format, whether
            passed in to the constructor or defaulted, will be used as the value
            of the <code>mimeType</code> attribute.</dd>

            <dt><dfn><code>audioBitsPerSecond</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>Aggregate target bits per second for encoding of the Audio
            track(s), if any. This is a hint for the encoder and the value
            might be surpassed, not achieved, or only be achieved over a long
            period of time.</dd>

            <dt><dfn><code>videoBitsPerSecond</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>Aggregate target bits per second for encoding of the Video
            track(s), if any. This is a hint for the encoder and the value
            might be surpassed, not achieved, or only be achieved over a long
            period of time.</dd>

            <dt><dfn><code>bitsPerSecond</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>Aggregate target bits per second for encoding of all Video and
            Audio Track(s) present. This parameter overrides either
            <code>audioBitsPerSecond</code> or <code>videoBitsPerSecond</code>
            if present, and might be distributed among the present track
            encoders as the UA sees fit. This parameter is a hint for the
            encoder(s) and the total value might be surpassed, not achieved, or
            only be achieved over a long period of time.</dd>
          </dl>
        </section>
      </div>
    </section>
    <section id="RecordingState">
      <h3>RecordingState</h3>
      <div>
        <pre class="idl">enum RecordingState {
    "inactive",
    "recording",
    "paused"
};</pre>
        <table data-link-for="RecordingState" data-dfn-for="RecordingState"
        class="simple">
          <tbody>
            <tr>
              <th colspan="2">Enumeration description</th>
            </tr>
            <tr>
              <td><dfn><code id=
              "idl-def-RecordingState.inactive">inactive</code></dfn></td>
              <td>Recording is not occuring. (Either it has not been started or
              it has been stopped.).</td>
            </tr>
            <tr>
              <td><dfn><code id=
              "idl-def-RecordingState.recording">recording</code></dfn></td>
              <td>Recording has been started and the UA is capturing
              data..</td>
            </tr>
            <tr>
              <td><dfn><code id=
              "idl-def-RecordingState.paused">paused</code></dfn></td>
              <td>Recording has been started, then paused, and not yet stopped
              or resumed.</td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>
  </section>
  <section id="blob-event">
    <h2>Blob Event</h2>
    <div>
      <pre class="idl">
      [ Constructor (DOMString type, BlobEventInit eventInitDict)]
interface BlobEvent : Event {
    readonly        attribute Blob data;
};</pre>
      <section>
        <h2>Constructors</h2>
        <dl data-link-for="BlobEvent" data-dfn-for="BlobEvent" class=
        "constructors">
          <dt><dfn><code>BlobEvent</code></dfn></dt>
          <dd>
            <table class="parameters">
              <tbody>
                <tr>
                  <th>Parameter</th>
                  <th>Type</th>
                  <th>Nullable</th>
                  <th>Optional</th>
                  <th>Description</th>
                </tr>
                <tr>
                  <td class="prmName">type</td>
                  <td class="prmType"><code>DOMString</code></td>
                  <td class="prmNullFalse"><span role="img" aria-label=
                  "False">&#10008;</span></td>
                  <td class="prmOptFalse"><span role="img" aria-label=
                  "False">&#10008;</span></td>
                  <td class="prmDesc">
                    Associated <a href=
                    "https://dom.spec.whatwg.org/#interface-event">Event
                    type.</a>
                  </td>
                </tr>
                <tr>
                  <td class="prmName">eventInitDict</td>
                  <td class="prmType"><code>BlobEventInit</code></td>
                  <td class="prmNullFalse"><span role="img" aria-label=
                  "False">&#10008;</span></td>
                  <td class="prmOptFalse"><span role="img" aria-label=
                  "False">&#10008;</span></td>
                  <td class="prmDesc">An initializer whose <code>data</code>
                  field will be used to initialize the attribute of the same
                  name.</td>
                </tr>
              </tbody>
            </table>
          </dd>
        </dl>
      </section>
      <section>
        <h2>Attributes</h2>
        <dl data-link-for="BlobEvent" data-dfn-for="BlobEvent" class=
        "attributes">
          <dt><dfn><code>data</code></dfn> of type <span class=
          "idlAttrType"><a>Blob</a></span>, readonly</dt>
          <dd>Returns a <a
          href="https://www.w3.org/TR/FileAPI/#blob"><code>Blob</code></a>
          object whose type attribute indicates the encoding of the blob
          data.</dd>
        </dl>
      </section>
    </div>
    <h3>BlobEventInit</h3>
    <div>
      <pre class="idl">
        dictionary BlobEventInit {
          required Blob data;
        };
      </pre>
      <section>
        <h2>Dictionary <a class="idlType">BlobEventInit</a> Members</h2>
        <dl data-link-for="BlobEventInit" data-dfn-for="BlobEventInit" class=
        "dictionary-members">
          <dt><dfn><code>data</code></dfn> of type <span class=
          "idlMemberType"><a>Blob</a></span>, required</dt>
          <dd>A Blob object containing the data to deliver via this event.</dd>
        </dl>
      </section>
    </div>
  </section>
  <section id="error-handling">
    <h2>Error Handling</h2>
    <section id="general-principles">
      <h3>General Principles</h3>
      <p>The UA MUST throw a <a href= "https://heycam.github.io/webidl/#idl-
      DOMException">DOMException</a> (see [[!DOM4]]) when the error can be
      detected at the time that the call is made. In all other cases, an
      <a><code>ErrorEvent</code></a> MUST be fired. If recording has been
      started and not yet stopped when the error occurs, then after raising the
      error, the UA MUST fire an event named <code>dataavailable</code>,
      containing any data that it has gathered, and then a <code>stop</code>
      event. The UA may set platform-specific limits, such as those for the
      minimum and maximum Blob size that it will support, or the number of
      Tracks it will record at once. It must signal a fatal error if these
      limits are exceeded.</p>
    </section>
    <section>
      <h3>ErrorEvent</h3>
      <p>The <a>ErrorEvent</a> interface is defined for cases when an event is raised
      that could have been caused by an error.</p> <p><dfn data-dfn-type="dfn"
      data-lt="fires an error event">Firing an error event named
      <var>e</var></dfn> with an <code>Error</code> <var>error</var> means that
      an event with the name <var>e</var>, which does not bubble (except where
      otherwise stated) and is not cancelable (except where otherwise stated),
      and which uses the <code><a>ErrorEvent</a></code> interface with the
      <code><a data-link-for= "ErrorEvent">error</a></code> attribute set to
      <var>error</var>, must be created and <a href="https://dom.spec.whatwg.org
      /#concept-event-dispatch">dispatched</a> at the given target. If no
      <code>Error</code> object is specified, the <code><a data-link-for=
      "ErrorEvent">error</a></code> attribute defaults to null.</p>
      <div>
        <pre class="idl">
          [Exposed=Window, Constructor (DOMString type, ErrorEventInit eventInitDict)]
          interface ErrorEvent : Event {
            readonly        attribute Error? error;
          };
        </pre>
        <section>
          <h2>Constructors</h2>
          <dl data-link-for="ErrorEvent" data-dfn-for="ErrorEvent" class=
          "constructors">
            <dt><code>ErrorEvent</code></dt>
            <dd>
              Constructs a new <code><a>ErrorEvent</a></code>.
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">type</td>
                    <td class="prmType"><code>DOMString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">eventInitDict</td>
                    <td class="prmType"><code>ErrorEventInit</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="ErrorEvent" data-dfn-for="ErrorEvent" class=
          "attributes">
            <dt><dfn><code>error</code></dfn> of type <span class=
            "idlAttrType"><a>Error</a></span>, readonly , nullable</dt>
            <dd>If the event was raised because of an error, this attribute MAY
            be set to that error object.</dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">
          dictionary ErrorEventInit : EventInit {
            Error? error = null;
          };
        </pre>
        <section>
          <h2>Dictionary <a class="idlType">ErrorEventInit</a> Members</h2>
          <dl data-link-for="ErrorEventInit" data-dfn-for="ErrorEventInit"
          class="dictionary-members">
            <dt><dfn><code>error</code></dfn> of type <span class=
            "idlMemberType"><a>Error</a></span>, nullable, defaulting to
            <code>null</code></dt>
            <dd>If the event was raised because of an error, this attribute MAY
            be set to that error object.</dd>
          </dl>
        </section>
      </div>
    </section>
    <section id="exception-summary" class="informative">
      <h3>Exception summary</h3>
      <p>Each of the exceptions defined in this document is a <a href=
      "http://www.w3.org/TR/2012/WD-dom-20121206/#exception-domexception"><code>
      DOMException</code></a> with a specific type. The exception types and
      properties such as code value are defined in [[!WEBIDL]].</p>
      <table class="vert">
        <thead>
          <tr>
            <th>Name</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>InvalidStateError</code></td>
            <td>An operation was called on an object on which it is not allowed
            or at a time when it is not allowed, or if a request is made on a
            source object that has been deleted or removed.</td>
          </tr>
          <tr>
            <td><code>NotSupportedError</code></td>
            <td>
              A <a><code>MediaRecorder</code></a> could not be created due to
              unsupported options (e.g. MIME type) specification. User agents
              should provide as much additional information as possible in the
              <code>message</code> attribute.
            </td>
          </tr>
          <tr>
            <td><code>SecurityError</code></td>
            <td>The isolation properties of the MediaStream do not allow the
            MediaRecorder access to it.</td>
          </tr>
        </tbody>
      </table>
    </section>
  </section>
  <section id="event-summary" class="informative">
    <h2>Event summary</h2>
    <p>The following additional events fire on <code><a>MediaRecorder</a></code>
    objects:</p>
    <table class="vert">
      <thead>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Fired when...</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><dfn id="event-mediarecorder-start"><code>start</code></dfn></td>
          <td><code>Event</code></td>
          <td>The UA has started recording data from the MediaStream.</td>
        </tr>
        <tr>
          <td><dfn id="event-mediarecorder-stop"><code>stop</code></dfn></td>
          <td><code>Event</code></td>
          <td>The UA has stopped recording data from the MediaStream.</td>
        </tr>
        <tr>
          <td><dfn id=
          "event-mediarecorder-dataavailable"><code>dataavailable</code></dfn></td>
          <td>
            <a><code>BlobEvent</code></a>
          </td>
          <td>The UA generates this even to return data to the application. The
          'data' attribute of this event contains a Blob of recorded data.</td>
        </tr>
        <tr>
          <td><dfn id="event-mediarecorder-pause"><code>pause</code></dfn></td>
          <td><code>Event</code></td>
          <td>The UA has paused recording data from the MediaStream.</td>
        </tr>
        <tr>
          <td><dfn id=
          "event-mediarecorder-resume"><code>resume</code></dfn></td>
          <td><code>Event</code></td>
          <td>The UA has resumed recording data from the MediaStream.</td>
        </tr>
        <tr>
          <td><dfn id=
          "event-mediarecorder-ErrorEvent"><code>ErrorEvent</code></dfn></td>
          <td><code>EventError</code></td>
          <td>An error has occurred, e.g. out of memory or a modification to
          the <code>stream</code> has occurred that makes it impossible to
          continue recording (e.g. a Track has been added to or removed from
          the said <code>stream</code> while recording is occurring).</td>
        </tr>
      </tbody>
    </table>
  </section>


  <section id="examples" class="informative">
  <h2>Examples</h2>

  <div class="note">
  Slightly modified versions of these examples can be found in e.g. <a
   href="https://codepen.io/collection/XjkNbN/">this codepen collection</a>.
   </div>

  <section>
  <h3>Check for <code>MediaRecorder</code> and <code>MIMEType</code>.</h3>

  <div class="note">
  The following example can also be found in e.g. <a
  href="https://codepen.io/miguelao/pen/edqNab?editors=0010">this codepen</a>
  with minimal modifications.
  </div>

  <pre class='example'>
  if (window.MediaRecorder == undefined) {
    console.error('MediaRecorder not supported, boo');
  } else {
    var codecs = ["video/webm",
                  "video/webm;codecs=vp8",
                  "audio/webm",
                  "video/mp4;codecs=h264",
                  "video/invalid"];
    codecs.forEach( codec => {
      console.log(codec + ' is ' +  (MediaRecorder.isTypeSupported(codec) ?
                                         'supported' : 'NOT supported '));
    });
  }
  </pre>
  </section>

  <section>
  <h3>Recording webcam video and audio</h3>
  <div class="note">
  The following example can also be found in e.g. <a
  href="https://codepen.io/miguelao/pen/wzVMJb?editors=0010">this codepen</a>
  with minimal modifications.
  </div>

  <pre class='example'>
  &lt;html>
  &lt;body>
  &lt;video autoplay/>
  &lt;script>
    var recordedChunks = [];

    function gotMedia(stream) {
      var video = document.querySelector('video');
      video.src = URL.createObjectURL(stream);
      var recorder = null;
      try {
        recorder = new MediaRecorder(stream, {mimeType : "video/webm"});
      } catch (e) {
        console.error('Exception while creating MediaRecorder: ' + e);
        return;
      }

      recorder.ondataavailable = (event) => {
        console.log(' Recorded chunk of size ' + event.data.size + "B");
        recordedChunks.push(event.data);
      };

      recorder.start(100);
    }

    navigator.mediaDevices.getUserMedia({video: true , audio: true})
        .then(gotMedia)
        .catch(e => { console.error('getUserMedia() failed: ' + e); });
  &lt;/script>
  &lt;/body>
  &lt;/html>
  </pre>

  <div class="note">
  <code>recordedChunks</code> can be saved to a file using e.g. the function
  <code>download()</code> in the <a
  href="https://developers.google.com/web/updates/2016/01/mediarecorder">
  MediaRecorder Web Fundamentals article</a>.
  </div>

  </section>

  </section>
</body>
</html>
